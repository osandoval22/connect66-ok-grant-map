<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connect66 Gateway Towers — OK Grant Map</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root { --bg:#0b1420; --fg:#e7eefc; --muted:#9fb3c8; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:20px 16px 8px; border-bottom: 3px solid #f7a600; }
    h1 { margin:0 0 4px 0; font-size: clamp(1.1rem, 2.8vw, 1.8rem); }
    .sub { color: var(--muted); font-size: 0.95rem; }
    #controls { position: fixed; right: 12px; top: 12px; background: #0f1b2a; color: var(--fg);
                border: 1px solid #233247; border-radius: 10px; padding: 10px 12px; z-index: 1000;
                box-shadow: 0 6px 18px rgba(0,0,0,.35); }
    #controls label { display:flex; align-items:center; gap:8px; margin:6px 0; font-size: 0.92rem; }
    #controls .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    #status { margin-top:8px; font-size: 0.9rem; color:#ffd18b; }
    #map { height: calc(100vh - 92px); width: 100%; }
    .pill { display:inline-block; background:#122235; color:#d6e4f5; padding:6px 10px; border-radius:999px; font-size:0.85rem; margin-right:8px; border:1px solid #22354c;}
    .legend { position: absolute; left: 12px; bottom: 16px; background:#0f1b2a; color:#fff; padding: 8px 10px; border-radius: 8px; border:1px solid #233247; font-size: 0.85rem; }
    .legend .swatch { display:inline-block; width:14px; height:14px; margin-right:6px; vertical-align: -2px; border-radius: 3px; }
  </style>
</head>
<body>
  <header>
    <h1>Connect66 Gateway Towers — Statewide Route 66 Infrastructure for the 2026 Centennial</h1>
    <div class="sub">
      <span class="pill">44 sites</span>
      <span class="pill">statewide coverage</span>
      <span class="pill">shovel-ready</span>
    </div>
  </header>

  <div id="controls">
    <div class="row">
      <label><input id="chkColorPop" type="checkbox" checked /> Color by population (if available)</label>
    </div>
    <div class="row">
      <label><input id="chkRoute" type="checkbox" /> Show route line</label>
      <label><input id="chkLabels" type="checkbox" /> Label distances</label>
    </div>
    <div id="status">Loading…</div>
  </div>

  <div id="map"></div>
  <div id="legend" class="legend" style="display:none;"></div>

<script>
// ---------- Helpers ----------
const rel = (p) => new URL(p, window.location.href).toString();

async function loadJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error('Failed to load ' + url + ' (' + r.status + ')');
  return r.json();
}

function toNum(v) {
  return Number(String(v ?? '').toString().replace(/,/g,'').trim());
}

function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371; // km
  const toRad = d => d * Math.PI/180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // kilometers
}

function midpoint(a, b) {
  return [ (a[0]+b[0])/2, (a[1]+b[1])/2 ];
}

// 5-bin color scale
const COLORS = ['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15'];

function quantizeScale(values) {
  const v = values.slice().sort((a,b)=>a-b);
  const bins = [0.2, 0.4, 0.6, 0.8].map(q => v[Math.max(0, Math.floor(q * (v.length-1)))]);
  return (x) => {
    if (!Number.isFinite(x) || v.length === 0) return '#9aa7b4';
    if (x <= bins[0]) return COLORS[0];
    if (x <= bins[1]) return COLORS[1];
    if (x <= bins[2]) return COLORS[2];
    if (x <= bins[3]) return COLORS[3];
    return COLORS[4];
  };
}

function renderLegend(breaks) {
  const el = document.getElementById('legend');
  if (!breaks) { el.style.display='none'; return; }
  el.innerHTML = '<div><strong>Population</strong></div>' +
    `<div><span class="swatch" style="background:${COLORS[0]}"></span> ≤ ${breaks[0].toLocaleString()}</div>` +
    `<div><span class="swatch" style="background:${COLORS[1]}"></span> ≤ ${breaks[1].toLocaleString()}</div>` +
    `<div><span class="swatch" style="background:${COLORS[2]}"></span> ≤ ${breaks[2].toLocaleString()}</div>` +
    `<div><span class="swatch" style="background:${COLORS[3]}"></span> ≤ ${breaks[3].toLocaleString()}</div>` +
    `<div><span class="swatch" style="background:${COLORS[4]}"></span> higher</div>`;
  el.style.display = 'block';
}

// ---------- Main ----------
(async () => {
  const status = document.getElementById('status');
  try {
    // Load your files from ./assets/
    const [cities, popsIndex] = await Promise.all([
      loadJSON(rel('./assets/cities.baked.json')).catch(() => loadJSON(rel('./cities.baked.json'))),
      loadJSON(rel('./assets/population.json')).catch(() => ({}))
    ]);

    // Normalize points
    const points = (Array.isArray(cities) ? cities : (cities.locations || cities.cities || []))
      .map(r => ({
        name: r.name || r.city || r.town || '',
        lat: Number(r.lat ?? r.latitude),
        lng: Number(r.lng ?? r.lon ?? r.longitude),
        // population may come from baked or separate index by name
        population: toNum(r.population ?? (popsIndex[r.name || r.city || '']))
      }))
      .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lng));

    if (!points.length) throw new Error('No valid coordinates in cities.baked.json');

    // Map
    const map = L.map('map');
    const bounds = L.latLngBounds(points.map(p => [p.lat, p.lng]));
    map.fitBounds(bounds.pad(0.15));
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);

    // Build population scale
    const popValues = points.map(p => p.population).filter(n => Number.isFinite(n) && n > 0);
    const scale = quantizeScale(popValues);
    const breaks = popValues.slice().sort((a,b)=>a-b);
    const legendBreaks = popValues.length ? [
      breaks[Math.floor(0.2*(breaks.length-1))],
      breaks[Math.floor(0.4*(breaks.length-1))],
      breaks[Math.floor(0.6*(breaks.length-1))],
      breaks[Math.floor(0.8*(breaks.length-1))],
    ] : null;

    // Layers
    const markersLayer = L.layerGroup().addTo(map);
    const routeLayer = L.layerGroup().addTo(map);
    const labelLayer = L.layerGroup().addTo(map);

    function drawMarkers(colorByPop) {
      markersLayer.clearLayers();
      points.forEach(p => {
        const color = colorByPop ? scale(p.population) : '#3fa3ff';
        const mk = L.circleMarker([p.lat, p.lng], {
          radius: 6, weight: 1.5, color: '#0b1d31', fillColor: color, fillOpacity: 0.95
        }).bindTooltip(`${p.name}${Number.isFinite(p.population) && p.population > 0 ? `<br>Pop: ${p.population.toLocaleString()}` : ''}`);
        mk.addTo(markersLayer);
      });
      if (colorByPop && legendBreaks) renderLegend(legendBreaks); else renderLegend(null);
    }

    function drawRoute(withLabels) {
      routeLayer.clearLayers();
      labelLayer.clearLayers();
      if (points.length < 2) return;

      const latlngs = points.map(p => [p.lat, p.lng]);
      L.polyline(latlngs, { weight: 3, color: '#ffd166' }).addTo(routeLayer);

      if (withLabels) {
        for (let i = 1; i < latlngs.length; i++) {
          const a = latlngs[i-1], b = latlngs[i];
          const km = haversine(a[0], a[1], b[0], b[1]);
          const mi = km * 0.621371;
          L.marker(midpoint(a,b), { opacity: 0.75 })
            .bindTooltip(`${mi.toFixed(1)} mi`, { permanent: true, direction: 'top', offset: [0,-8], opacity: 0.9 })
            .addTo(labelLayer);
        }
      }
    }

    // Initial draw
    const chkColorPop = document.getElementById('chkColorPop');
    const chkRoute = document.getElementById('chkRoute');
    const chkLabels = document.getElementById('chkLabels');

    drawMarkers(chkColorPop.checked);
    drawRoute(false);

    chkColorPop.addEventListener('change', () => drawMarkers(chkColorPop.checked));
    chkRoute.addEventListener('change', () => {
      if (!chkRoute.checked) { routeLayer.clearLayers(); labelLayer.clearLayers(); return; }
      drawRoute(chkLabels.checked);
    });
    chkLabels.addEventListener('change', () => {
      if (!chkRoute.checked) return;
      drawRoute(chkLabels.checked);
    });

    status.textContent = '';
  } catch (e) {
    console.error(e);
    const status = document.getElementById('status');
    status.textContent = 'Error: ' + e.message;
  }
})();
</script>
</body>
</html>
