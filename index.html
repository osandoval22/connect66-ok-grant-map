<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connect66 — OK Sequential Distances + Population</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root { --bg:#0b1420; --fg:#e7eefc; --muted:#9fb3c8; --panel:#0f1b2a; }
    * { box-sizing: border-box; }
    body { margin:0; display:flex; min-height:100vh; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { position:fixed; left:0; right:340px; top:0; padding:14px 16px; background:var(--bg); border-bottom:3px solid #f7a600; z-index:5;}
    header h1 { margin:0; font-size: clamp(1.05rem,2.2vw,1.6rem); }
    #map { position:absolute; top:62px; left:0; right:340px; bottom:0; }
    aside { position:fixed; right:0; top:0; bottom:0; width:340px; background:var(--panel); border-left:1px solid #233247; padding:12px 12px 16px; overflow:auto; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:8px 0 4px; }
    label, select { font-size:0.9rem; }
    select { background:#13243a; color:#e7eefc; border:1px solid #2a4060; border-radius:8px; padding:6px 8px; }
    #status { color:#ffd18b; font-size:0.9rem; margin:8px 0; }
    ol { margin:8px 0 0 18px; padding:0; }
    ol li { margin:6px 0; line-height: 1.25; }
    .small { color:var(--muted); font-size:0.9rem; }
    .total { margin-top:10px; font-weight:600; }
    .city-badge { display:inline-block; min-width:18px; height:18px; border-radius:50%; background:#ffd166; color:#000; text-align:center; font-weight:700; font-size:12px; line-height:18px; margin-right:6px;}
    .legend { position:absolute; left:12px; bottom:16px; background:#0f1b2a; color:#fff; padding:8px 10px; border-radius:8px; border:1px solid #233247; font-size:0.85rem; }
    .legend .swatch { display:inline-block; width:14px; height:14px; margin-right:6px; vertical-align:-2px; border-radius:3px; }
    /* High-contrast permanent labels */
    .leaflet-tooltip.dist-label {
      background: rgba(0,0,0,0.72);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 6px;
      padding: 2px 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
      font-weight: 600;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Connect66 — Oklahoma Sequential Distances + Population</h1>
  </header>

  <div id="map"></div>
  <div id="legend" class="legend" style="display:none;"></div>

  <aside>
    <div class="row">
      <label><input type="checkbox" id="chkColor" checked /> Color by population</label>
    </div>
    <div class="row">
      <label><input type="checkbox" id="chkLabels" checked /> Show distance labels</label>
    </div>
    <div class="row">
      <label for="orderSel">Ordering:</label>
      <select id="orderSel">
        <option value="dataset" selected>Dataset sequence</option>
        <option value="west_east">Longitude: West → East</option>
        <option value="east_west">Longitude: East → West</option>
      </select>
    </div>
    <div id="status">Loading…</div>
    <div id="list"></div>
  </aside>

<script>
const rel = p => new URL(p, window.location.href).toString();

async function loadJSON(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error('Failed to load ' + url + ' (' + r.status + ')');
  return r.json();
}
function toNum(v){ return Number(String(v ?? '').replace(/,/g,'').trim()); }
function haversine(lat1, lon1, lat2, lon2) {
  const R=6371, toRad=d=>d*Math.PI/180;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); // km
}
function midpoint(a,b){ return [(a[0]+b[0])/2,(a[1]+b[1])/2]; }

// color scale
const COLORS=['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15'];
function quantizeScale(values){
  const v=values.slice().filter(n=>Number.isFinite(n)&&n>0).sort((a,b)=>a-b);
  if(!v.length) return Object.assign(()=> '#3fa3ff',{breaks:null});
  const bins=[0.2,0.4,0.6,0.8].map(q=>v[Math.floor(q*(v.length-1))]);
  const fn=(x)=>{
    if(!Number.isFinite(x)||x<=0) return '#9aa7b4';
    if(x<=bins[0])return COLORS[0];
    if(x<=bins[1])return COLORS[1];
    if(x<=bins[2])return COLORS[2];
    if(x<=bins[3])return COLORS[3];
    return COLORS[4];
  };
  return Object.assign(fn,{breaks:bins});
}

(async () => {
  const status=document.getElementById('status');
  try {
    const [cities, pops] = await Promise.all([
      loadJSON(rel('./assets/cities.baked.json')).catch(()=>loadJSON(rel('./cities.baked.json'))),
      loadJSON(rel('./assets/population.json')).catch(()=> ({}))
    ]);

    let raw = (Array.isArray(cities) ? cities : (cities.locations || cities.cities || []));
    raw = raw.map(r => ({
      ...r,
      name: r.name || r.city || r.town || '',
      lat: Number(r.lat ?? r.latitude),
      lng: Number(r.lng ?? r.lon ?? r.longitude),
      population: toNum(r.population ?? (pops[r.name || r.city || ''])),
    })).filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lng));

    if (!raw.length) throw new Error('No valid coordinates in cities.baked.json');

    // Identify an order field if present
    const orderKeys = ['order','sequence','seq','index','idx','rank','position'];
    const hasOrderKey = orderKeys.find(k => raw.some(r => typeof r[k] !== 'undefined'));
    // fallback order will be longitude West->East
    function sortBy(mode, arr){
      const a = arr.slice();
      if(mode==='dataset' && hasOrderKey){
        a.sort((x,y) => (Number(x[hasOrderKey])||0) - (Number(y[hasOrderKey])||0));
      } else if(mode==='east_west'){
        a.sort((x,y) => y.lng - x.lng);
      } else {
        a.sort((x,y) => x.lng - y.lng);
      }
      return a;
    }

    // Map
    const map=L.map('map');
    const bounds=L.latLngBounds(raw.map(p=>[p.lat,p.lng]));
    map.fitBounds(bounds.pad(0.15));
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

    const scale=quantizeScale(raw.map(p=>p.population));

    // Layers
    const markers=L.layerGroup().addTo(map);
    const segments=L.layerGroup().addTo(map);
    const labels=L.layerGroup().addTo(map);

    // Legend
    function renderLegend(){
      const el=document.getElementById('legend');
      const br=scale.breaks;
      if(!br){ el.style.display='none'; return; }
      el.innerHTML = '<div><strong>Population</strong></div>' +
        `<div><span class="swatch" style="background:${COLORS[0]}"></span> ≤ ${br[0].toLocaleString()}</div>` +
        `<div><span class="swatch" style="background:${COLORS[1]}"></span> ≤ ${br[1].toLocaleString()}</div>` +
        `<div><span class="swatch" style="background:${COLORS[2]}"></span> ≤ ${br[2].toLocaleString()}</div>` +
        `<div><span class="swatch" style="background:${COLORS[3]}"></span> ≤ ${br[3].toLocaleString()}</div>` +
        `<div><span class="swatch" style="background:${COLORS[4]}"></span> higher</div>`;
      el.style.display='block';
    }

    function drawAll(){
      const orderMode=document.getElementById('orderSel').value;
      const colorByPop=document.getElementById('chkColor').checked;
      const showLabels=document.getElementById('chkLabels').checked;

      const points = sortBy(orderMode, raw);

      markers.clearLayers(); segments.clearLayers(); labels.clearLayers();

      // markers
      points.forEach((p,idx)=>{
        const color=colorByPop? scale(p.population): '#3fa3ff';
        L.circleMarker([p.lat,p.lng],{radius:7, weight:1.6, color:'#0b1d31', fillColor:color, fillOpacity:0.95})
          .bindTooltip(`${idx+1}. ${p.name}${Number.isFinite(p.population)&&p.population>0? `<br>Pop: ${p.population.toLocaleString()}`:''}`)
          .addTo(markers);
        const num=L.divIcon({className:'city-idx', html:`<div class="city-badge">${idx+1}</div>`, iconSize:[18,18]});
        L.marker([p.lat,p.lng],{icon:num, interactive:false}).addTo(markers);
      });

      // sequential segments only
      for(let i=1;i<points.length;i++){
        const a=points[i-1], b=points[i];
        const seg = L.polyline([[a.lat,a.lng],[b.lat,b.lng]],{color:'#ffd166', weight:3}).addTo(segments);
        if(showLabels){
          const mi = haversine(a.lat,a.lng,b.lat,b.lng)*0.621371;
          L.tooltip({permanent:true, direction:'top', className:'dist-label', offset:[0,-6]})
            .setLatLng(midpoint([a.lat,a.lng],[b.lat,b.lng]))
            .setContent(`${i}→${i+1}: ${mi.toFixed(1)} mi`)
            .addTo(labels);
        }
      }

      // list
      const list=document.getElementById('list');
      let html='<ol>', total=0;
      for(let i=1;i<points.length;i++){
        const a=points[i-1], b=points[i];
        const mi=haversine(a.lat,a.lng,b.lat,b.lng)*0.621371; total+=mi;
        const ap = Number.isFinite(a.population) && a.population>0 ? a.population.toLocaleString() : 'N/A';
        const bp = Number.isFinite(b.population) && b.population>0 ? b.population.toLocaleString() : 'N/A';
        html += `<li><strong>${i}→${i+1}</strong> ${a.name} <span class="small">(pop: ${ap})</span> → ${b.name} <span class="small">(pop: ${bp})</span> <span class="small">(${mi.toFixed(1)} mi)</span></li>`;
      }
      html+='</ol>';
      html+=`<div class="total">Total (series): ${total.toFixed(1)} mi</div>`;
      list.innerHTML=html;

      renderLegend();
    }

    // initial
    drawAll();

    // controls
    document.getElementById('chkColor').addEventListener('change', drawAll);
    document.getElementById('chkLabels').addEventListener('change', drawAll);
    document.getElementById('orderSel').addEventListener('change', drawAll);

    status.textContent='';
  } catch (e) {
    console.error(e);
    document.getElementById('status').textContent='Error: '+e.message;
  }
})();
</script>
</body>
</html>
